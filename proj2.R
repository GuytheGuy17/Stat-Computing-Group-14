#' Group Members: 
#' Guy McClennan - s2036567
#' Alexandru Girban - s2148980
#' Louis Bennett - s2744241
#' 
#'- Louis: Wrote the basis of the deconv function and designed the plots.
#'- Guy: Wrote the Pearson statistic, t0 and probability functions. Structured
#' the code and did commenting. 
#'- Alex: Optimized the code and implemented bootstrapping.

# setwd("~/Stat-Computing-Group-14")

#' pearson_stat
#' 
#' @description Calculates the Pearson statistic to measure the goodness of fit.
#' @param observed_data A vector of actual deaths.
#' @param simulated_data A vector of simulated deaths. 
#' @return The value of the Pearson statistic generated by the given vectors.

pearson_stat <- function(observed_data, simulated_data) {
  sum((observed_data - simulated_data) ^ 2 / pmax(simulated_data, 1))
}

#' calc_days_to_deaths_probs
#' 
#' @description Creates a vector of normalized probabilities for how long it takes from
#' initial infection to death using a log-normal distribution.
#' @param max_duration The maximum length of infection-to-death duration.
#' @param meanlog The mean of the log-normal distribution based on previous studies.
#' @param sdlog The standard deviation of the log-normal distribution based on previous studies.
#' @return Returns the normalized vector of days-to-death probabilities.

calc_days_to_death_probs <- function(max_duration = 80, meanlog = 3.152, sdlog = 0.451) {
  # Set up infection-to-death distribution
  probabilities <- dlnorm(1:max_duration, meanlog, sdlog)
  return(probabilities / sum(probabilities))  # Normalize
}

#' create_t0
#' 
#' @description This function generates a vector t0 of initial guesses for days 
#' of infection.
#' @param days A vector of dates of possible infection.
#' @param deaths A vector deaths on given days.
#' @param max_duration The maximum length of infection-to-death duration.
#' @return Returns a vector t0 of that contains initial days of infection estimates.

create_t0 <- function(days, deaths, max_duration = 80) {
  probabilities <- calc_days_to_death_probs(max_duration)
  
  # Calculate total deaths and create death days vector
  total_deaths <- sum(deaths)
  death_days <- rep(days, deaths)
  
  # Generate infection-to-death durations
  durations <- sample(1:max_duration, total_deaths, replace = TRUE, prob = probabilities)
  
  # Calculate initial guesses for infection days
  t0 <- death_days - durations
  
  # set negative values to 0
  t0[t0 <= 1] <- 1
  
  return(t0)
}

#' deconv
#' 
#' @description Implements the basic algorithm using the create_t0 and 
#' calc_days_to_death_probs functions to infer fatal incidence rates from Covid 
#' deaths in English hospitals.
#' @param t A vector containing the days of the year on which deaths occurred.
#' @param deaths A vector containing the number of deaths occurring each day.
#' @param n.rep The number of times we iterate our fitting. 
#' @param bs Indicates whether we are using bootstrapping.
#' @param t0 A converged vector used if we are using bootstrapping.
#' @return A list containing the vector of Pearson statistic values for each n.rep
#' iterations, a 310 Ã— n.rep matrix inft, each column of which contains the number 
#' of new infections per day, according to the state of t0 after each full update 
#' and an n vector t0 containing the final state of t0.

deconv <- function(t, deaths, n.rep = 100, bs = FALSE, t0 = NULL) {
  # check inputs for errors
  if(length(t) != length(deaths)) stop('Vector of days should be the same length as the vector of deaths')
  if(bs == TRUE & is.null(t0)) stop('If `bs` = TRUE, then supply a converged t0 vector')
  
  if(is.null(t0)) {
    t0 <- create_t0(t, deaths)
  }
  
  n <- length(t0)
  
  # extend deaths to 1 to 310 days
  ext_deaths <- numeric(length = 310)
  ext_deaths[t] <- deaths
  
  # initial vectors/matrices to store history of P and infections
  P_hist <- numeric(length = n.rep)
  inft <- matrix(nrow = length(ext_deaths), ncol = n.rep)
  
  # calculate the probabilities for drawing from later
  probs <- calc_days_to_death_probs()
  
  for(j in 1:n.rep) {
    # initialize options for days
    if(j <= 50) {
      days_opt <- c(-8, -4, -2, -1, 1, 2, 4, 8)
    } else if(j <= 75) {
      days_opt <- c(-4, -2, -1, 1, 2, 4)
    } else {
      days_opt <- c(-2, -1, 1, 2)
    }
    
    # perform the bootstrapping sample
    if(bs == TRUE) {
      sim_deaths <- rpois(length(ext_deaths), ext_deaths)
    } else {
      sim_deaths <- ext_deaths
    }
    
    days_to_death <- sample(1:80, n, replace = TRUE, prob = probs)
    
    # create pred_deaths - nbins 310 to match the length
    pred_deaths <- tabulate(t0 + days_to_death, nbins = 310)
    
    # calculate the initial pearson statistic in step 4
    P <- pearson_stat(sim_deaths, pred_deaths)
    
    # sample random changes
    rand_change <- sample(days_opt, n, replace = TRUE)
    
    # Add 2 new vectors to store the proposed changes
    t0_proposed <- t0
    pred_deaths_proposed <- pred_deaths
    
    sampled_indices <- sample(1:n, n)
    
    # sample 1:n means loop is over in a random order
    for(i in sampled_indices) {
      # add random change - don't want to propose a negative number of days so replace with 0
      t0_proposed[i] <- max(t0[i] + rand_change[i], 1)
      
      # recalcuate day of death and the previous day of death
      proposed_death_day <- t0_proposed[i] + days_to_death[i]
      
      old_death_day <- t0[i] + days_to_death[i]
      
      # inject these into the predicted deaths
      pred_deaths_proposed[proposed_death_day] <- pred_deaths_proposed[proposed_death_day] + 1
      pred_deaths_proposed[old_death_day] <- pred_deaths_proposed[old_death_day] - 1
      
      # recalculate the pearson statistic
      P_proposed <- pearson_stat(sim_deaths, pred_deaths_proposed)
      
      # if P_proposed < P then update all our vectors (strictly less than - in case of equality don't update for efficiency)
      if(P_proposed < P) {
        pred_deaths[proposed_death_day] <- pred_deaths_proposed[proposed_death_day]
        pred_deaths[old_death_day] <- pred_deaths_proposed[old_death_day]
        t0[i] <- t0_proposed[i]
        P <- P_proposed
      } else { # else reset back to old vectors
        t0_proposed[i] <- t0[i]
        pred_deaths_proposed[proposed_death_day] <- pred_deaths[proposed_death_day] 
        pred_deaths_proposed[old_death_day] <- pred_deaths[old_death_day]
      }
    }
    
    # only plot each 10 iterations to see the convergence
    if(j %% 10 == 1 & bs == FALSE) {
      # create plot
      plot(x = 1:310, y = ext_deaths, type = 'l', xlab = 'Days', ylab = 'Count')
      lines(x = 1:310, y = tabulate(t0, nbins = 310), col = 'blue')
      lines(x = 1:310, y = pred_deaths, col = 'red')
      legend(x = 175, y = 900, legend = c('Estimated Incidence', 'Simulated Deaths', 'Real Deaths'), fill = c('blue', 'red', 'black'))
    }
    
    P_hist[j] <- P
    inft[, j] <- tabulate(t0, nbins = 310)
  }
  
  list(
    P = P_hist,
    inft = inft,
    t0 = t0
  )
  
}

# Only using the first 150 rows of the data for this practical.
initial_data <- read.table("engcov.txt", nrows = 150)

# using n.rep = 100 to get a converged t0
run <- deconv(initial_data$julian, initial_data$nhs, n.rep = 100)

# use the converged t0 with bootstrapping now, take 100 samples
bootstrapped_run <- deconv(initial_data$julian, initial_data$nhs, n.rep = 100, bs = TRUE, t0 = run$t0)

# find the 2.5% and 97.5% of bootstrapped data by day
confbounds <- apply(bootstrapped_run$inft, 1, function(x) quantile(x, probs = c(0.025, 0.975), names = FALSE))

# calculate mean cases for the first plot
to_average <- run$inft[, run$P <= 150]
mean_cases <- apply(to_average, 1, mean)

# create the first plot
plot.new()
plot.window(xlim = c(1, 310), ylim = c(min(confbounds), max(confbounds)))

# calculate month breaks
dates <- as.Date("2019-12-31") + c(1:310)
break_ind <- which(format(dates, '%d') == '01')
labels <- format(dates[break_ind], '%b')

axis(2); axis(1, labels = labels, at = break_ind); box()
# add CIs
polygon(x = c(1:310, 310:1), c(confbounds[1, ], rev(confbounds[2, ])), col = 'grey', border = NA)
# add the cases according to t0
lines(x = 1:310, y = mean_cases, type = 'l', xlab = 'Days', ylab = 'Count')
# add deaths data
lines(x = initial_data$julian, y = initial_data$nhs, col = 'blue')
abline(v = 84, lty = 'dashed')
# make plot readable - add label and legend
text(x = 84, y = max(mean_cases), labels = 'UK Lockdown', pos = 4)
legend(x = 310, y = max(mean_cases), legend = c('Estimated Incidences', 'Deaths'), col = c('black', 'blue'), lty = 'solid', xjust = 1, yjust = 1, cex = 0.8)
title(main = 'Estimated Fatal Covid-19 Incidences By Day In 2020\nCompared With Deaths By Day', sub = 'Shaded grey region represents a 95% confidence interval', xlab = 'Date')

# create the plot comparing real and simulated deaths
# extend deaths to 1 to 230 (230 = 150 + 80 which is the last possible day of death)
ext_deaths <- numeric(length = 230)
ext_deaths[initial_data$julian] <- initial_data$nhs

plot.new()
plot.window(xlim = c(1, length(ext_deaths)), ylim = c(min(ext_deaths), max(ext_deaths)))

axis(2); axis(1, labels = labels, at = break_ind); box()

# simulate bootstrapped data and plot each
for(i in 1:100) {
  sim_deaths <- rpois(length(ext_deaths), ext_deaths)
  
  lines(x = 1:length(ext_deaths), y = sim_deaths, col = 'lightgrey', alpha = 0.2)
}


# add real data
lines(x = 1:length(ext_deaths), y = ext_deaths, col = 'blue')

# add title and legend
legend(x = length(ext_deaths), y = max(ext_deaths), legend = c('Simulated Deaths', 'Real Deaths'), col = c('lightgrey', 'blue'), lty = 'solid', xjust = 1, yjust = 1, cex = 0.8)
title(main = 'Comparison Of Simulated Data And Real Deaths Data', xlab = 'Date')
